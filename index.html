<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Huge Heart PNG Generator (Tiled)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: linear-gradient(180deg,#fff 0%, #ffeef0 100%);
      margin: 0;
      padding: 24px;
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .panel {
      background: white;
      padding: 18px;
      border-radius: 10px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.07);
      max-width: 720px;
    }
    input[type="number"] { width: 140px; padding:8px; font-size:14px; margin-right:8px; }
    button { padding:10px 14px; border-radius:8px; border: none; cursor: pointer; background: #e23d6b; color: white; font-size:14px; }
    .hint { color:#555; margin-top:10px; font-size:13px; }
    .preview { width:120px; height:120px; display:block; margin-top:10px; border-radius:8px; overflow:hidden; }
    pre { background:#fafafa; padding:8px; border-radius:6px; font-size:12px; overflow:auto; }
  </style>
</head>
<body>
  <div class="panel" role="main" aria-labelledby="title">
    <h2 id="title">Huge Heart PNG Generator — Tiled Rendering</h2>

    <div>
      <label>Output size (px):</label>
      <input id="sizeInput" type="number" min="512" step="256" value="20000" />
      <button id="startBtn">Generate & Download</button>
    </div>

    <p class="hint" id="status">Tip: very large sizes use a lot of RAM. If tab becomes unresponsive, choose a smaller size.</p>

    <img class="preview" src="" alt="preview" id="previewImg" />

    <p class="hint"><strong>Recommended test sizes</strong>: 2000, 5000, 10000, 20000. Start small and increase.</p>
  </div>

<script>
/*
  Strategy:
  - Create heart as an SVG data URL (512x512).
  - Load it into an Image.
  - Create a large canvas of chosen size.
  - Render the SVG repeatedly into the canvas by drawing it scaled into tiles (tile by tile).
  - After each tile we yield to the event loop (setTimeout 0) so the page doesn't hard-freeze.
  - Overlay per-tile random noise (small circles) to increase PNG entropy (bigger file size).
  - Finally call canvas.toBlob and programmatically download the PNG.
*/

const svgBaseSize = 512;
const svgString = `
<svg xmlns="http://www.w3.org/2000/svg" width="${svgBaseSize}" height="${svgBaseSize}" viewBox="0 0 512 512">
  <rect width="100%" height="100%" fill="#ffffff"/>
  <path fill="#e23d6b" d="M471.7 73.2c-54.5-46.2-136.6-39.6-186.4 13.7L256 116.6l-29.4-29.7c-49.9-53.3-131.9-59.9-186.4-13.7-62.6 53-66.1 149.6-9.9 207.3L239 487.4c12 11.6 31.6 11.6 43.6 0L481.6 280.5c56.2-57.7 52.7-154.3-9.9-207.3z"/>
</svg>
`.trim();

function svgToDataUrl(s) {
  return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(s)));
}

function sleep(ms=0){ return new Promise(r=>setTimeout(r,ms)); }

async function generateAndDownload(sizePx) {
  const statusEl = document.getElementById('status');
  statusEl.textContent = `Preparing generation for ${sizePx} × ${sizePx}...`;

  const img = new Image();
  img.src = svgToDataUrl(svgString);
  // on some browsers, data URL images need crossOrigin not set; leave unset.

  await new Promise((resolve, reject) => {
    img.onload = () => resolve();
    img.onerror = (e) => reject(new Error('Failed to load SVG image'));
  });

  // Create big canvas
  const canvas = document.createElement('canvas');
  canvas.width = sizePx;
  canvas.height = sizePx;
  const ctx = canvas.getContext('2d');

  // Tile settings: choose tile size so each tile is reasonable (smaller => more yields)
  // We target about 100-400 tiles depending on size
  const preferredTilePx = 2000; // try tiles around this pixel size
  const tilesAcross = Math.max(1, Math.ceil(sizePx / preferredTilePx));
  const tileW = Math.ceil(sizePx / tilesAcross);
  const tileH = tileW; // square tiles

  const totalTiles = tilesAcross * tilesAcross;
  let done = 0;

  statusEl.textContent = `Rendering ${totalTiles} tiles (this can take a while)...`;

  // Draw each tile
  for (let ty = 0; ty < tilesAcross; ty++){
    for (let tx = 0; tx < tilesAcross; tx++){
      const dx = tx * tileW;
      const dy = ty * tileH;
      // actual width/height for edge tiles
      const dw = Math.min(tileW, sizePx - dx);
      const dh = Math.min(tileH, sizePx - dy);

      // Draw the SVG scaled for this tile by drawing entire SVG scaled to the tile size.
      // drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh)
      // We draw the full SVG but scaled to tile area.
      ctx.drawImage(img, 0, 0, svgBaseSize, svgBaseSize, dx, dy, dw, dh);

      // Add randomized small noise (few circles) to increase entropy per-tile
      // keep noise count moderate to avoid huge CPU hit
      const noiseCount = Math.min(200, Math.max(50, Math.floor((dw*dh)/(1000*1000)) * 50));
      for (let i=0;i<noiseCount;i++){
        const cx = dx + Math.random() * dw;
        const cy = dy + Math.random() * dh;
        const r = Math.random() * 3; // tiny circles
        // pick light colors in the heart palette
        ctx.beginPath();
        ctx.fillStyle = (Math.random() > 0.5) ? 'rgba(255,202,212,0.9)' : 'rgba(255,192,203,0.9)';
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fill();
      }

      done++;
      // update status occasionally
      if (done % Math.max(1, Math.floor(totalTiles/20)) === 0) {
        statusEl.textContent = `Rendering tiles: ${done}/${totalTiles} completed...`;
      }

      // Yield to event loop so UI remains somewhat responsive
      await sleep(0);
    }
  }

  statusEl.textContent = 'Finalizing PNG blob (this can take a moment)...';

  // Convert to blob and download
  await new Promise((resolve, reject) => {
    // PNG at default quality (lossless); browsers may take some time and memory here
    canvas.toBlob(async (blob) => {
      if (!blob) return reject(new Error('Failed to create PNG blob'));
      // preview smaller scaled version for the user
      const preview = document.getElementById('previewImg');
      // create small preview by creating an object URL of a canvas scaled down
      try {
        const previewCanvas = document.createElement('canvas');
        const p = 120;
        previewCanvas.width = p;
        previewCanvas.height = p;
        const pctx = previewCanvas.getContext('2d');
        pctx.drawImage(canvas, 0, 0, p, p);
        preview.src = previewCanvas.toDataURL('image/png');
      } catch(e) {
        // ignore preview errors
      }

      // Trigger download
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `huge_heart_${sizePx}px.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      // revoke after a short while
      setTimeout(()=>URL.revokeObjectURL(link.href), 2000);
      statusEl.textContent = 'Download initiated. Check your Downloads folder.';
      resolve();
    }, 'image/png');
  });
}

document.getElementById('startBtn').addEventListener('click', async () => {
  const input = document.getElementById('sizeInput');
  let val = Number(input.value) || 20000;
  // Safety caps: prevent accidental insane sizes; change if you want
  if (val > 40000) {
    if (!confirm('You selected an extremely large size (>40k). This may crash your browser. Continue?')) return;
  }
  // run generation
  try {
    await generateAndDownload(val);
  } catch (err) {
    document.getElementById('status').textContent = 'Error: ' + (err && err.message ? err.message : String(err));
    console.error(err);
  }
});
</script>
</body>
</html>
